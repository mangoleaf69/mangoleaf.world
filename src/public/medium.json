{
  "status": "ok",
  "feed": {
    "url": "https://medium.com/feed/@mangoleaf96d343",
    "title": "Stories by mangoleaf on Medium",
    "link": "https://medium.com/@mangoleaf96d343?source=rss-bf1474b7e499------2",
    "author": "",
    "description": "Stories by mangoleaf on Medium",
    "image": "https://cdn-images-1.medium.com/fit/c/150/150/0*2mhj8Lbc6uxW80x2"
  },
  "items": [
    {
      "title": "Optimizing Saga Peak Detection.",
      "pubDate": "2024-07-20 12:27:43",
      "link": "https://medium.com/@mangoleaf96d343/optimizing-saga-peak-detection-9388f8fba9e0?source=rss-bf1474b7e499------2",
      "guid": "https://medium.com/p/9388f8fba9e0",
      "author": "mangoleaf",
      "thumbnail": "",
      "description": "\n<p>Hi so on the path to making a terrain process using GDAL and SAGA. We have come to a point where we need to find the peeks. I have found a combination of down sampling used for previews TPI process <a href=\"https://medium.com/@mangoleaf96d343/exploring-topographic-position-index-tpi-with-raster-data-8ad9985161cb\">(here)</a> and Gaussian smoothing with window radius 3 and sigma 2 as well as doing 4 iteration gave good results at 4m, 16m, and 64m DEM resolution.</p>\n<h3>Optimizing Terrain Analysis with Gaussian Filtering</h3>\n<p>In geospatial analysis, accurately detecting terrain features such as peaks is essential for various applications from environmental modeling to infrastructure planning. However, achieving reliable peak detection in flatland regions like Ontario presents challenges due to subtle elevation variations. To address this, an optimized approach using Gaussian filtering in SAGA GIS is proposed, emphasizing iterative refinement to enhance peak detection accuracy.</p>\n<h3>Motivation</h3>\n<p>Flatland terrains often exhibit gentle slopes and subtle elevation changes, making traditional peak detection methods less effective. By leveraging Gaussian filtering, which smooths out noise and emphasizes significant terrain features, we aim to enhance the visibility of peaks and valleys that may otherwise be obscured by noise or low-resolution data.</p>\n<h3>Methodology</h3>\n<p><strong>1. Gaussian Filtering Iterations:</strong><br>\u200a\u2014\u200a<strong>Purpose</strong>: Reduce noise and highlight prominent terrain features.<br>\u200a\u2014\u200a<strong>Implementation</strong>: The script iteratively applies Gaussian filtering with specified parameters:<br>\u200a\u2014\u200a<strong>Sigma</strong>: Controls the spread of Gaussian distribution (default: 2).<br> \u2014<strong>Window Size:</strong> Determines the size of the filter window (default: 3).<br>\u200a\u2014\u200a<strong>Number of Rounds:</strong> Specifies how many times Gaussian filtering is applied (default: 4).</p>\n<p><strong>2. Peak Detection Using SAGA GIS:</strong><br>\u200a\u2014\u200a<strong>Tool:</strong> Utilizes SAGA GIS\u2019s `shapes_grid` tool to detect local minima and maxima.<br>\u200a\u2014\u200a<strong>Benefit</strong>: Enables precise identification and delineation of peaks based on the refined DEM resulting from Gaussian filtering iterations.</p>\n<h3>Practical Implementation</h3>\n<pre>#!/bin/bash<br><br># Default values<br>sigma=2<br>window_size=3<br>num_rounds=4  # Number of rounds of Gaussian filtering<br><br># Function to display script usage<br>usage() {<br>    echo \"Usage: $0 -i &lt;input_file&gt; [-s &lt;sigma&gt;] [-w &lt;window_size&gt;] [-n &lt;num_rounds&gt;]\"<br>    echo \"  -i &lt;input_file&gt;: Input grid file (any format)\"<br>    echo \"  -s &lt;sigma&gt;: Standard deviation for Gaussian filter (default: 2)\"<br>    echo \"  -w &lt;window_size&gt;: Window size for Gaussian filter (default: 3)\"<br>    echo \"  -n &lt;num_rounds&gt;: Number of rounds of Gaussian filtering (default: 4)\"<br>    exit 1<br>}<br><br># Parse command-line options<br>while getopts \":i:s:w:n:\" opt; do<br>    case $opt in<br>        i) input_file=\"$OPTARG\" ;;<br>        s) sigma=\"$OPTARG\" ;;<br>        w) window_size=\"$OPTARG\" ;;<br>        n) num_rounds=\"$OPTARG\" ;;<br>        \\?) echo \"Invalid option: -$OPTARG\" &gt;&amp;2; usage ;;<br>        :) echo \"Option -$OPTARG requires an argument.\" &gt;&amp;2; usage ;;<br>    esac<br>done<br><br># Check if input file is provided<br>if [ -z \"$input_file\" ]; then<br>    echo \"ERROR: INPUT GRID FILE IS REQUIRED.\"<br>    usage<br>fi<br><br># Check if input file exists<br>if [ ! -f \"$input_file\" ]; then<br>    echo \"ERROR: INPUT FILE '$input_file' NOT FOUND.\"<br>    exit 1<br>fi<br><br># Determine input file extension<br>input_extension=\"${input_file##*.}\"<br><br># Apply Gaussian filter for specified number of rounds<br>current_file=\"$input_file\"<br>output_file=\"$input_file\"<br>for (( round=1; round&lt;=$num_rounds; round++ )); do<br>    output_file=\"${current_file%.*}_G${sigma}-${window_size}.sgrd\"<br>    echo \"APPLYING GAUSSIAN FILTER: ROUND $round\"<br>    saga_cmd grid_filter 0 -INPUT \"$current_file\" -METHOD 0 -KERNEL_TYPE 0 -KERNEL_RADIUS $window_size -RESULT \"$output_file\"<br>    current_file=$output_file<br>done<br><br># Determine output filenames for shapes_grid based on final output_file<br>minima_output=\"${output_file%.*}_minima.shp\"<br>maxima_output=\"${output_file%.*}_maxima.shp\"<br><br># Run local minimum and maximum operations<br>echo \"RUNNING LOCAL MINIMUM AND MAXIMUM OPERATIONS $output_file\"<br>saga_cmd shapes_grid 9 -GRID \"$output_file\" -MINIMA \"$minima_output\" -MAXIMA \"$maxima_output\"<br><br># Check if the command was successful<br>if [ $? -ne 0 ]; then<br>    echo \"ERROR: FAILED TO EXECUTE SHAPES_GRID.\"<br>    exit 1<br>fi<br><br>echo \"PROCESSING COMPLETE.\"</pre>\n<p>Above is the script and bellow is my usage in my end proccess:</p>\n<pre>bash dem_tools_tho/local_minima_maxima_with_smoothing.sh -i $d4_path -s 2 -w 3 -n 4<br>bash dem_tools_tho/local_minima_maxima_with_smoothing.sh -i $d16_path -s 2 -w 3 -n 4<br>bash dem_tools_tho/local_minima_maxima_with_smoothing.sh -i $d64_path -s 2 -w 3 -n 4</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iL4vyQkZoDYwpjj03jgz7w.jpeg\"></figure><h3>Conclusion</h3>\n<p>The iterative application of Gaussian filtering in SAGA GIS offers a robust method for enhancing peak detection in flatland terrains. By systematically reducing noise and emphasizing significant terrain features, this approach improves the accuracy and reliability of peak identification. The integration of `shapes_grid` tool facilitates detailed analysis by precisely detecting local minima and maxima based on the refined DEM, supporting informed decision-making in terrain-related applications.</p>\n<h4>\n<strong>Tool Description: </strong>SAGA GIS `shapes_grid`</h4>\n<p>The `<strong>shapes_grid</strong>` tool in SAGA GIS is designed for detecting and analyzing shapes within grid data. Specifically, it identifies local minima and maxima in digital elevation models (DEMs), crucial for terrain feature extraction and analysis. By outputting shapefiles (.shp) representing minima and maxima, it enables detailed visualization and further geospatial analysis of terrain characteristics.</p>\n<h4>Implement this optimized approach in your terrain analysis workflows to leverage advanced geospatial tools for accurate peak detection and terrain feature extraction.</h4>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9388f8fba9e0\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<p>Hi so on the path to making a terrain process using GDAL and SAGA. We have come to a point where we need to find the peeks. I have found a combination of down sampling used for previews TPI process <a href=\"https://medium.com/@mangoleaf96d343/exploring-topographic-position-index-tpi-with-raster-data-8ad9985161cb\">(here)</a> and Gaussian smoothing with window radius 3 and sigma 2 as well as doing 4 iteration gave good results at 4m, 16m, and 64m DEM resolution.</p>\n<h3>Optimizing Terrain Analysis with Gaussian Filtering</h3>\n<p>In geospatial analysis, accurately detecting terrain features such as peaks is essential for various applications from environmental modeling to infrastructure planning. However, achieving reliable peak detection in flatland regions like Ontario presents challenges due to subtle elevation variations. To address this, an optimized approach using Gaussian filtering in SAGA GIS is proposed, emphasizing iterative refinement to enhance peak detection accuracy.</p>\n<h3>Motivation</h3>\n<p>Flatland terrains often exhibit gentle slopes and subtle elevation changes, making traditional peak detection methods less effective. By leveraging Gaussian filtering, which smooths out noise and emphasizes significant terrain features, we aim to enhance the visibility of peaks and valleys that may otherwise be obscured by noise or low-resolution data.</p>\n<h3>Methodology</h3>\n<p><strong>1. Gaussian Filtering Iterations:</strong><br>\u200a\u2014\u200a<strong>Purpose</strong>: Reduce noise and highlight prominent terrain features.<br>\u200a\u2014\u200a<strong>Implementation</strong>: The script iteratively applies Gaussian filtering with specified parameters:<br>\u200a\u2014\u200a<strong>Sigma</strong>: Controls the spread of Gaussian distribution (default: 2).<br> \u2014<strong>Window Size:</strong> Determines the size of the filter window (default: 3).<br>\u200a\u2014\u200a<strong>Number of Rounds:</strong> Specifies how many times Gaussian filtering is applied (default: 4).</p>\n<p><strong>2. Peak Detection Using SAGA GIS:</strong><br>\u200a\u2014\u200a<strong>Tool:</strong> Utilizes SAGA GIS\u2019s `shapes_grid` tool to detect local minima and maxima.<br>\u200a\u2014\u200a<strong>Benefit</strong>: Enables precise identification and delineation of peaks based on the refined DEM resulting from Gaussian filtering iterations.</p>\n<h3>Practical Implementation</h3>\n<pre>#!/bin/bash<br><br># Default values<br>sigma=2<br>window_size=3<br>num_rounds=4  # Number of rounds of Gaussian filtering<br><br># Function to display script usage<br>usage() {<br>    echo \"Usage: $0 -i &lt;input_file&gt; [-s &lt;sigma&gt;] [-w &lt;window_size&gt;] [-n &lt;num_rounds&gt;]\"<br>    echo \"  -i &lt;input_file&gt;: Input grid file (any format)\"<br>    echo \"  -s &lt;sigma&gt;: Standard deviation for Gaussian filter (default: 2)\"<br>    echo \"  -w &lt;window_size&gt;: Window size for Gaussian filter (default: 3)\"<br>    echo \"  -n &lt;num_rounds&gt;: Number of rounds of Gaussian filtering (default: 4)\"<br>    exit 1<br>}<br><br># Parse command-line options<br>while getopts \":i:s:w:n:\" opt; do<br>    case $opt in<br>        i) input_file=\"$OPTARG\" ;;<br>        s) sigma=\"$OPTARG\" ;;<br>        w) window_size=\"$OPTARG\" ;;<br>        n) num_rounds=\"$OPTARG\" ;;<br>        \\?) echo \"Invalid option: -$OPTARG\" &gt;&amp;2; usage ;;<br>        :) echo \"Option -$OPTARG requires an argument.\" &gt;&amp;2; usage ;;<br>    esac<br>done<br><br># Check if input file is provided<br>if [ -z \"$input_file\" ]; then<br>    echo \"ERROR: INPUT GRID FILE IS REQUIRED.\"<br>    usage<br>fi<br><br># Check if input file exists<br>if [ ! -f \"$input_file\" ]; then<br>    echo \"ERROR: INPUT FILE '$input_file' NOT FOUND.\"<br>    exit 1<br>fi<br><br># Determine input file extension<br>input_extension=\"${input_file##*.}\"<br><br># Apply Gaussian filter for specified number of rounds<br>current_file=\"$input_file\"<br>output_file=\"$input_file\"<br>for (( round=1; round&lt;=$num_rounds; round++ )); do<br>    output_file=\"${current_file%.*}_G${sigma}-${window_size}.sgrd\"<br>    echo \"APPLYING GAUSSIAN FILTER: ROUND $round\"<br>    saga_cmd grid_filter 0 -INPUT \"$current_file\" -METHOD 0 -KERNEL_TYPE 0 -KERNEL_RADIUS $window_size -RESULT \"$output_file\"<br>    current_file=$output_file<br>done<br><br># Determine output filenames for shapes_grid based on final output_file<br>minima_output=\"${output_file%.*}_minima.shp\"<br>maxima_output=\"${output_file%.*}_maxima.shp\"<br><br># Run local minimum and maximum operations<br>echo \"RUNNING LOCAL MINIMUM AND MAXIMUM OPERATIONS $output_file\"<br>saga_cmd shapes_grid 9 -GRID \"$output_file\" -MINIMA \"$minima_output\" -MAXIMA \"$maxima_output\"<br><br># Check if the command was successful<br>if [ $? -ne 0 ]; then<br>    echo \"ERROR: FAILED TO EXECUTE SHAPES_GRID.\"<br>    exit 1<br>fi<br><br>echo \"PROCESSING COMPLETE.\"</pre>\n<p>Above is the script and bellow is my usage in my end proccess:</p>\n<pre>bash dem_tools_tho/local_minima_maxima_with_smoothing.sh -i $d4_path -s 2 -w 3 -n 4<br>bash dem_tools_tho/local_minima_maxima_with_smoothing.sh -i $d16_path -s 2 -w 3 -n 4<br>bash dem_tools_tho/local_minima_maxima_with_smoothing.sh -i $d64_path -s 2 -w 3 -n 4</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iL4vyQkZoDYwpjj03jgz7w.jpeg\"></figure><h3>Conclusion</h3>\n<p>The iterative application of Gaussian filtering in SAGA GIS offers a robust method for enhancing peak detection in flatland terrains. By systematically reducing noise and emphasizing significant terrain features, this approach improves the accuracy and reliability of peak identification. The integration of `shapes_grid` tool facilitates detailed analysis by precisely detecting local minima and maxima based on the refined DEM, supporting informed decision-making in terrain-related applications.</p>\n<h4>\n<strong>Tool Description: </strong>SAGA GIS `shapes_grid`</h4>\n<p>The `<strong>shapes_grid</strong>` tool in SAGA GIS is designed for detecting and analyzing shapes within grid data. Specifically, it identifies local minima and maxima in digital elevation models (DEMs), crucial for terrain feature extraction and analysis. By outputting shapefiles (.shp) representing minima and maxima, it enables detailed visualization and further geospatial analysis of terrain characteristics.</p>\n<h4>Implement this optimized approach in your terrain analysis workflows to leverage advanced geospatial tools for accurate peak detection and terrain feature extraction.</h4>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9388f8fba9e0\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "gis",
        "detection",
        "peek"
      ]
    },
    {
      "title": "Exploring Topographic Position Index (TPI) with Raster Data",
      "pubDate": "2024-07-17 05:06:57",
      "link": "https://medium.com/@mangoleaf96d343/exploring-topographic-position-index-tpi-with-raster-data-8ad9985161cb?source=rss-bf1474b7e499------2",
      "guid": "https://medium.com/p/8ad9985161cb",
      "author": "mangoleaf",
      "thumbnail": "",
      "description": "\n<h4>Introduction</h4>\n<p>Topographic Position Index (TPI) is a fundamental tool in geomorphology and landscape analysis, helping to classify terrain features based on their elevation relative to surrounding areas. In this article, we delve into the application of TPI using high-resolution Digital Elevation Models (DEMs) derived from LiDAR\u00a0data.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Alg9iaa-VrOEDdMiO3Vceg.png\"><figcaption>75% overlay of TPI with\u00a0DEM</figcaption></figure><h4>Methodology</h4>\n<h4>Data Preparation</h4>\n<p>We begin with a 1-meter resolution DEM obtained from LiDAR, providing detailed elevation data for our study area. Understanding the spatial scale is crucial, so we employ a downsampling technique to create multiple resolutions: 4x downsample iterations, resulting in pixel sizes approximately representing scales of 4m, 16m, 64m, and\u00a0256m.</p>\n<h4>TPI Calculation Methods</h4>\n<p>Two primary methods are explored for calculating TPI:</p>\n<p>1. **gdaldem tpi:** This method computes TPI using a single-pixel radius window, making it fast and suitable for initial analyses. <a href=\"https://gdal.org/programs/gdaldem.html\">https://gdal.org/programs/gdaldem.html</a></p>\n<p>2. **sega tpi tool 28:** A more sophisticated approach allowing customization of minimum and maximum scales, effectively widening the kernel radius for filtering. This method provides flexibility to capture larger terrain features, enhancing the granularity of analysis. <a href=\"https://saga-gis.sourceforge.io/saga_tool_doc/7.4.0/ta_morphometry_28.html\">https://saga-gis.sourceforge.io/saga_tool_doc/7.4.0/ta_morphometry_28.html</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PhssmPBD7cAxCIeGtuAIEQ.png\"><figcaption>original 1m dem from\u00a0lidar</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tSlxi28sCQrF7Ghm1Ahh-w.png\"><figcaption>Only TPI down sampled 4x4=16 times this 8\u201332 tpi filter in 4\u00a0steps</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/897/1*l_MoiVbqZqPSS3hzF7H8Jg.png\"><figcaption>Zoomed in look at both overlayed</figcaption></figure><h3>Challenges</h3>\n<h4>Scale Dependency</h4>\n<p>One of the critical challenges in TPI analysis is determining the appropriate scale for the study. Scale affects the identification and characterization of terrain features\u200a\u2014\u200asmaller scales highlight finer details, while larger scales capture broader landscape patterns.</p>\n<h4>Computational Resources</h4>\n<p>The computational intensity of processing high-resolution DEMs at multiple scales poses challenges, particularly with methods like `sega tpi` requiring significant processing time per tile. Optimizing workflows and leveraging parallel processing can mitigate these challenges.</p>\n<h3>Results and Interpretation</h3>\n<h4>Visualization and\u00a0Analysis</h4>\n<p>Visualizing TPI outputs reveals distinct terrain features such as peaks, valleys, and ridges. Each downsampling iteration and TPI method provides unique insights: higher resolutions capture finer details, while broader scales emphasize larger landforms.</p>\n<h4>Integration and Comparison</h4>\n<p>Integrating downscaled TPI outputs and comparing them allows for a comprehensive landscape analysis. This approach enhances our understanding of terrain dynamics across different spatial scales, aiding in environmental modeling and decision-making processes.</p>\n<h3>Conclusion</h3>\n<p>Topographic Position Indexing is a versatile tool for terrain analysis, offering insights into landscape morphology and geomorphological processes. By leveraging advanced DEM processing techniques and scaling methodologies, researchers can uncover intricate spatial patterns critical for ecological, geological, and urban planning\u00a0studies.</p>\n<h4>Future Directions</h4>\n<p>Future research directions may focus on automating TPI workflows, integrating machine learning algorithms for feature detection, and refining TPI methodologies for even greater precision and efficiency.</p>\n<p>In conclusion, TPI remains pivotal in understanding landscape dynamics, offering researchers powerful insights into terrain characterization and environmental modeling.</p>\n<p><a href=\"https://asciinema.org/a/Yp4N4lwb1sVaKgm2pgmht9Xvx\">dem_tools_tho/downsample_n_f_tpi.sh Lets make some TPI</a></p>\n<a href=\"https://medium.com/media/880f42c6fa23d40af4f9f235f224dd05/href\">https://medium.com/media/880f42c6fa23d40af4f9f235f224dd05/href</a><a href=\"https://medium.com/media/83363ab5d707a115d67678b86273def6/href\">https://medium.com/media/83363ab5d707a115d67678b86273def6/href</a><pre>#!/bin/bash<br><br><br><br>function normalise_one_sigma() {<br># Check if the input file is provided<br>if [ \"$#\" -ne 1 ]; then<br>    echo \"Usage: $0 &lt;input_raster.tif&gt;\"<br>    exit 1<br>fi<br><br># Input raster file<br>input_raster=$1<br><br>gdalinfo -stats \"$input_raster\"<br><br># Get mean and standard deviation using gdalinfo<br>mean=$(gdalinfo -json \"$input_raster\" | jq '.bands[0].mean')<br>std=$(gdalinfo -json \"$input_raster\" | jq '.bands[0].stdDev')<br><br># Debugging output<br>echo \"Mean: $mean  StdDev: $std\"<br><br># Check if mean and std were successfully extracted<br>if [ -z \"$mean\" ] || [ -z \"$std\" ]; then<br>    echo \"Error: Could not extract mean or standard deviation.\"<br>    exit 1<br>fi<br><br># Output raster file<br>output_raster=\"${input_raster%.*}_n1.tif\"<br><br># Normalize the raster using gdal_calc.py<br>gdal_calc.py -A \"$input_raster\" --calc=\"(A - $mean) / $std\" --NoDataValue=-9999 --outfile=\"$output_raster\" --overwrite<br><br>echo \"Normalization complete. Output saved as $output_raster.\"<br>}<br><br><br><br><br><br><br># Check if the input DEM file is provided<br>if [ $# -lt 1 ]; then<br>    echo \"Usage: $0 &lt;input_dem&gt; [&lt;num_iterations&gt;] [&lt;downsample_factor&gt;]\"<br>    exit 1<br>fi<br><br># Input DEM file<br>dem=$1<br>num_iterations=${2:-2}  # Default to 2 iterations if not provided<br>downsample_factor=${3:-2}  # Default to downsample factor of 2 if not provided<br><br>echo \"Starting TPI calculation process...\"<br>echo \"Input DEM: $dem\"<br>echo \"Number of iterations: $num_iterations\"<br>echo \"Downsample factor: $downsample_factor\"<br><br># Get original dimensions<br>original_size=$(gdalinfo \"$dem\" | grep 'Size is' | awk '{print $3, $4}')<br>width=$(echo $original_size | cut -d',' -f1)<br>height=$(echo $original_size | cut -d',' -f2)<br>echo \"Original size: Width = $width, Height = $height\"<br><br># Recursive downsampling and TPI calculation<br>current_dem=\"$dem\"<br><br>for ((i = 1; i &lt;= num_iterations; i++)); do<br>    new_width=$((width / (downsample_factor ** i)))<br>    new_height=$((height / (downsample_factor ** i)))<br><br>    output_dem=\"${current_dem%.*}_D${downsample_factor}.tif\"<br><br>    # Downsampling step<br>    echo \"Generating downsampled DEM: $output_dem\"<br>    gdalwarp -ts $new_width $new_height -r bilinear \"$current_dem\" \"$output_dem\" -overwrite<br><br>    if [ $? -eq 0 ]; then<br>        echo \"Downsampled image created: $output_dem\"<br><br>        # TPI calculation<br>        tpi_output=\"${output_dem%.*}_tpi.tif\"<br>        echo \"Calculating TPI for: $output_dem\"<br>        ## here we could replace this with<br>        ## sega_tpi.sh \"$output_dem\"<br>        gdaldem tpi \"$output_dem\" \"$tpi_output\" -compute_edges<br><br>        normalise_one_sigma $tpi_output<br><br>        if [ $? -eq 0 ]; then<br>            echo \"TPI calculated and saved to: $tpi_output\"<br>        else<br>            echo \"Error calculating TPI for: $output_dem\"<br>            exit 1<br>        fi<br><br>        current_dem=\"$output_dem\"  # Update current DEM for the next iteration<br>    else<br>        echo \"Error creating downsampled image: $output_dem\"<br>        exit 1<br>    fi<br>done<br><br>echo \"TPI calculation process completed.\"</pre>\n<pre>#!/bin/bash<br><br># Input DEM file path<br>input_file=$1<br><br>min=3<br>max=8<br>step=2<br># Output file path (where TPI will be saved)<br><br>output_file=\"${input_file%.*}_TPI$min-$max-$step.tif\"<br><br># SAGA command to calculate TPI<br>saga_cmd ta_morphometry 28 \\<br>    -DEM \"$input_file\" \\<br>    -TPI \"$output_file\" \\<br>    -SCALE_MIN \"$min\" \\<br>    -SCALE_MAX \"$max\" \\<br>    -SCALE_NUM \"$step\"</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8ad9985161cb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "content": "\n<h4>Introduction</h4>\n<p>Topographic Position Index (TPI) is a fundamental tool in geomorphology and landscape analysis, helping to classify terrain features based on their elevation relative to surrounding areas. In this article, we delve into the application of TPI using high-resolution Digital Elevation Models (DEMs) derived from LiDAR\u00a0data.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Alg9iaa-VrOEDdMiO3Vceg.png\"><figcaption>75% overlay of TPI with\u00a0DEM</figcaption></figure><h4>Methodology</h4>\n<h4>Data Preparation</h4>\n<p>We begin with a 1-meter resolution DEM obtained from LiDAR, providing detailed elevation data for our study area. Understanding the spatial scale is crucial, so we employ a downsampling technique to create multiple resolutions: 4x downsample iterations, resulting in pixel sizes approximately representing scales of 4m, 16m, 64m, and\u00a0256m.</p>\n<h4>TPI Calculation Methods</h4>\n<p>Two primary methods are explored for calculating TPI:</p>\n<p>1. **gdaldem tpi:** This method computes TPI using a single-pixel radius window, making it fast and suitable for initial analyses. <a href=\"https://gdal.org/programs/gdaldem.html\">https://gdal.org/programs/gdaldem.html</a></p>\n<p>2. **sega tpi tool 28:** A more sophisticated approach allowing customization of minimum and maximum scales, effectively widening the kernel radius for filtering. This method provides flexibility to capture larger terrain features, enhancing the granularity of analysis. <a href=\"https://saga-gis.sourceforge.io/saga_tool_doc/7.4.0/ta_morphometry_28.html\">https://saga-gis.sourceforge.io/saga_tool_doc/7.4.0/ta_morphometry_28.html</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PhssmPBD7cAxCIeGtuAIEQ.png\"><figcaption>original 1m dem from\u00a0lidar</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tSlxi28sCQrF7Ghm1Ahh-w.png\"><figcaption>Only TPI down sampled 4x4=16 times this 8\u201332 tpi filter in 4\u00a0steps</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/897/1*l_MoiVbqZqPSS3hzF7H8Jg.png\"><figcaption>Zoomed in look at both overlayed</figcaption></figure><h3>Challenges</h3>\n<h4>Scale Dependency</h4>\n<p>One of the critical challenges in TPI analysis is determining the appropriate scale for the study. Scale affects the identification and characterization of terrain features\u200a\u2014\u200asmaller scales highlight finer details, while larger scales capture broader landscape patterns.</p>\n<h4>Computational Resources</h4>\n<p>The computational intensity of processing high-resolution DEMs at multiple scales poses challenges, particularly with methods like `sega tpi` requiring significant processing time per tile. Optimizing workflows and leveraging parallel processing can mitigate these challenges.</p>\n<h3>Results and Interpretation</h3>\n<h4>Visualization and\u00a0Analysis</h4>\n<p>Visualizing TPI outputs reveals distinct terrain features such as peaks, valleys, and ridges. Each downsampling iteration and TPI method provides unique insights: higher resolutions capture finer details, while broader scales emphasize larger landforms.</p>\n<h4>Integration and Comparison</h4>\n<p>Integrating downscaled TPI outputs and comparing them allows for a comprehensive landscape analysis. This approach enhances our understanding of terrain dynamics across different spatial scales, aiding in environmental modeling and decision-making processes.</p>\n<h3>Conclusion</h3>\n<p>Topographic Position Indexing is a versatile tool for terrain analysis, offering insights into landscape morphology and geomorphological processes. By leveraging advanced DEM processing techniques and scaling methodologies, researchers can uncover intricate spatial patterns critical for ecological, geological, and urban planning\u00a0studies.</p>\n<h4>Future Directions</h4>\n<p>Future research directions may focus on automating TPI workflows, integrating machine learning algorithms for feature detection, and refining TPI methodologies for even greater precision and efficiency.</p>\n<p>In conclusion, TPI remains pivotal in understanding landscape dynamics, offering researchers powerful insights into terrain characterization and environmental modeling.</p>\n<p><a href=\"https://asciinema.org/a/Yp4N4lwb1sVaKgm2pgmht9Xvx\">dem_tools_tho/downsample_n_f_tpi.sh Lets make some TPI</a></p>\n<a href=\"https://medium.com/media/880f42c6fa23d40af4f9f235f224dd05/href\">https://medium.com/media/880f42c6fa23d40af4f9f235f224dd05/href</a><a href=\"https://medium.com/media/83363ab5d707a115d67678b86273def6/href\">https://medium.com/media/83363ab5d707a115d67678b86273def6/href</a><pre>#!/bin/bash<br><br><br><br>function normalise_one_sigma() {<br># Check if the input file is provided<br>if [ \"$#\" -ne 1 ]; then<br>    echo \"Usage: $0 &lt;input_raster.tif&gt;\"<br>    exit 1<br>fi<br><br># Input raster file<br>input_raster=$1<br><br>gdalinfo -stats \"$input_raster\"<br><br># Get mean and standard deviation using gdalinfo<br>mean=$(gdalinfo -json \"$input_raster\" | jq '.bands[0].mean')<br>std=$(gdalinfo -json \"$input_raster\" | jq '.bands[0].stdDev')<br><br># Debugging output<br>echo \"Mean: $mean  StdDev: $std\"<br><br># Check if mean and std were successfully extracted<br>if [ -z \"$mean\" ] || [ -z \"$std\" ]; then<br>    echo \"Error: Could not extract mean or standard deviation.\"<br>    exit 1<br>fi<br><br># Output raster file<br>output_raster=\"${input_raster%.*}_n1.tif\"<br><br># Normalize the raster using gdal_calc.py<br>gdal_calc.py -A \"$input_raster\" --calc=\"(A - $mean) / $std\" --NoDataValue=-9999 --outfile=\"$output_raster\" --overwrite<br><br>echo \"Normalization complete. Output saved as $output_raster.\"<br>}<br><br><br><br><br><br><br># Check if the input DEM file is provided<br>if [ $# -lt 1 ]; then<br>    echo \"Usage: $0 &lt;input_dem&gt; [&lt;num_iterations&gt;] [&lt;downsample_factor&gt;]\"<br>    exit 1<br>fi<br><br># Input DEM file<br>dem=$1<br>num_iterations=${2:-2}  # Default to 2 iterations if not provided<br>downsample_factor=${3:-2}  # Default to downsample factor of 2 if not provided<br><br>echo \"Starting TPI calculation process...\"<br>echo \"Input DEM: $dem\"<br>echo \"Number of iterations: $num_iterations\"<br>echo \"Downsample factor: $downsample_factor\"<br><br># Get original dimensions<br>original_size=$(gdalinfo \"$dem\" | grep 'Size is' | awk '{print $3, $4}')<br>width=$(echo $original_size | cut -d',' -f1)<br>height=$(echo $original_size | cut -d',' -f2)<br>echo \"Original size: Width = $width, Height = $height\"<br><br># Recursive downsampling and TPI calculation<br>current_dem=\"$dem\"<br><br>for ((i = 1; i &lt;= num_iterations; i++)); do<br>    new_width=$((width / (downsample_factor ** i)))<br>    new_height=$((height / (downsample_factor ** i)))<br><br>    output_dem=\"${current_dem%.*}_D${downsample_factor}.tif\"<br><br>    # Downsampling step<br>    echo \"Generating downsampled DEM: $output_dem\"<br>    gdalwarp -ts $new_width $new_height -r bilinear \"$current_dem\" \"$output_dem\" -overwrite<br><br>    if [ $? -eq 0 ]; then<br>        echo \"Downsampled image created: $output_dem\"<br><br>        # TPI calculation<br>        tpi_output=\"${output_dem%.*}_tpi.tif\"<br>        echo \"Calculating TPI for: $output_dem\"<br>        ## here we could replace this with<br>        ## sega_tpi.sh \"$output_dem\"<br>        gdaldem tpi \"$output_dem\" \"$tpi_output\" -compute_edges<br><br>        normalise_one_sigma $tpi_output<br><br>        if [ $? -eq 0 ]; then<br>            echo \"TPI calculated and saved to: $tpi_output\"<br>        else<br>            echo \"Error calculating TPI for: $output_dem\"<br>            exit 1<br>        fi<br><br>        current_dem=\"$output_dem\"  # Update current DEM for the next iteration<br>    else<br>        echo \"Error creating downsampled image: $output_dem\"<br>        exit 1<br>    fi<br>done<br><br>echo \"TPI calculation process completed.\"</pre>\n<pre>#!/bin/bash<br><br># Input DEM file path<br>input_file=$1<br><br>min=3<br>max=8<br>step=2<br># Output file path (where TPI will be saved)<br><br>output_file=\"${input_file%.*}_TPI$min-$max-$step.tif\"<br><br># SAGA command to calculate TPI<br>saga_cmd ta_morphometry 28 \\<br>    -DEM \"$input_file\" \\<br>    -TPI \"$output_file\" \\<br>    -SCALE_MIN \"$min\" \\<br>    -SCALE_MAX \"$max\" \\<br>    -SCALE_NUM \"$step\"</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8ad9985161cb\" width=\"1\" height=\"1\" alt=\"\">\n",
      "enclosure": {},
      "categories": [
        "dem",
        "tpi",
        "gis",
        "topographic-maps",
        "shell"
      ]
    }
  ]
}